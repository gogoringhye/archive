<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        //배열의 메서드(배열이 가지고 있는 함수)
        //[1]객체 
        //배열--> 일반적으로 같은 타입의 데이터를 묶어서 사용 ==> 동적타입언어에서는 타입에 관계없이 사용함
        //객체는 특성(특징)들을 묶어서 줄 수 있고(속성), 해당 객체의 동작(메서드)도 정의해서 묶어줄 수 있음.


        const ar = [];
        ar.push('국어');
        ar.push('영어');
        ar.push('수학');

        console.log(ar) //['국어', '영어', '수학'], push는 배열 끝에 밀어넣는 것

        const arr = [1, 2, 3, 4, 5, 6]
        console.log(arr) //[1,2,3,4,5,6]

        //처음 값과 끝값
        const animals = ['tiger', 'alligator', 'elephant', 'dog', 'cat', 'sheep', 'hippo'];

        console.log(animals[0]) //처음값
        console.log(animals[4]) //cat
        console.log(animals.length) //7
        console.log(animals[animals.length - 1]) //맨 끝 값을 구하는 방법(전체 - 1, 마이너스 할 때는 무조건 띄워쓰기 적어주기)

        //undefined 값을 가지는 경우(error와 다름)
        console.log(animals[5]); //sheep
        console.log(animals[10]); //undefined(값이 없는 게 아님, 선언은 됐는데 할당되지 않은 것)

        // 콘솔 정리
        console.clear();

        //배열의 반복과 출력
        // 1. 전통적인 for 반복문
        // 2. for .. in, for .. of 반복문
        // 3. 배열명.foreach();
        // 4. spread Opreator(펼침 연산자) ... 

        // 1. 전통적인 for 반복문
        //const animals = ['tiger', 'alligator', 'elephant', 'dog', 'cat', 'sheep', 'hippo'];
        for (let i = 0; i < animals.length; i++) { //i+=1 또는 i=i+1라고 적어도 같은 의미(하나씩 커진다는 의미 외에 ++을 적는 일은 없음)


            console.log(animals[i])
        }

        // 2. for .. in, for .. of 반복문

        // 콘솔 정리
        console.clear();
        // for (let 변수(배열 안에 있는 아이템이 순서대로 변수로 호출됨) of 배열명){}
        for (let item of animals) {
            console.log(item) //tiger alligator elephant dog cat sheep hippo
        }


        for (let item in animals) {
            console.log(item) //0 1 2 3 4 5 6 --> index
            console.log(animals[item]) //tiger alligator elephant dog cat sheep hippo
        }

        // 3. 배열명.foreach(){});
        // 첫번째 매개변수(item) --> 아이템(item 안에 들어있는 각각의 요소들) 각각이 호출됨
        // 두번째 매개변수(ind) --> 아이템 각각의 index가 호출
        // 세번째 매개변수 --> 원배열 animals
        console.clear();
        animals.forEach(function (item, ind, oriarr) {
            //console.log(item)
            //console.log(ind)
            //console.log(oriarr)
        })

        animals.forEach(function (ele) {
            console.log(ele) //tiger alligator elephant dog cat sheep hippo
        })


        //화살표 함수로 변경하기
        //Arrow function(=>)
        //    animals.forEach((ele)=>{
        //     console.log(ele)
        //    })

        //명령문이 한 줄 일 땐 중괄호를 삭제할 수 있음
        //    animals.forEach((ele)=>
        //     console.log(ele)
        //    )

        //매개변수가 딱 한개일 때만 괄호 생략 가능(매개변수가 없는 경우도 불가능)
        //animals.forEach((ele)=>console.log(ele))
        animals.forEach(ele => console.log(ele))


        // 4. spread Opreator(펼침 연산자) ... 

        // 콘솔 정리
        console.clear();

        console.log(...animals)

        // 삽입과 삭제
        // push(),pop()--> 뒤에서 삽입하고 삭제
        // unshift(), shift() --> 앞에서 삽입하고 삭제 --> 쉬프트는 배열의 정렬에 사용
        let testAr = [1, 2, 3, 4, 5, 6];
        testAr.push(7)
        testAr.pop(7)
        testAr.pop()
        testAr.pop() //가장 마지막 아이템이 빠져나감
        console.log(testAr)

        testAr.unshift('a')
        console.log(testAr) //['a', 1, 2, 3, 4]

        testAr.shift()
        console.log(testAr) //[ 1, 2, 3, 4]
        testAr.shift()
        console.log(testAr) //[2, 3, 4]

        // split()메서드
        // 기능 --> 문자열을 배열로 리턴 --> 문자열에서 특정한 구분자를 기준으로 잘라내서 새로운 배열로 리턴
        // 사용 --> 문자열. split(구분자,limit)

        let someSt = "가랑잎이 솔잎더러 바스락거린다고 한다";
        // let splitted = someSt.split(" ");
        // console.log(splitted)//['가랑잎이', '솔잎더러', '바스락거린다고', '한다'], 띄어쓰기를 기준으로 리턴됨
        let splitted = someSt.split(" ", 2);
        console.log(splitted) //['가랑잎이', '솔잎더러']

        let someSt2 = "진도, 제주도, 거제도, 독도, 마라도";
        // let splitted2=someSt2.split(', ')
        // console.log(splitted2)//(5) ['진도', '제주도', '거제도', '독도', '마라도']

        let splitted2 = someSt2.split(', ', 4)
        console.log(splitted2) //['진도', '제주도','거제도, '독도'], 반점과 띄어쓰기를 기준으로 리턴됨

        //slice() 메서드 --> 비교하여 splice()메서드
        //slice, splice--> 둘은 비슷하나 차이점이 있다. --> slice()
        //메서드는 원본 배열을 수정하지 않음. --> 즉, 새로운 배열을 리턴

        //splice() --> 원본 배열을 수정함

        //1)사용법
        //slice(start)
        //slice(start, end)// end는 지정한 end 전까지를 잘라냄
        console.clear();
        let sliceArr = ['tiger', 'alligator', 'elephant', 'dog', 'cat', 'sheep', 'hippo'];

        //배열명.slice(1)//인덱스 1포함해서 그 뒤로는 모두 잘라냄

        let slideAr1 = sliceArr.slice(1)
        console.log(slideAr1) //'alligator', 'elephant', 'dog', 'cat', 'sheep', 'hippo'
        console.log(sliceArr) //원본보존


        let slideAr2 = sliceArr.slice(1, 4); //인덱스 1,2,3
        console.log(slideAr2) //['alligator', 'elephant', 'dog']

        const sliceNums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

        const slideArNum1 = sliceNums.slice(5); //숫자 5 X, 인덱스가 5인 것부터 잘라내겠다는 의미임
        console.log(slideArNum1) // [6, 7, 8, 9, 10]
        console.log(sliceNums) //[1,2,3,4,5,6,7,8,9,10];


        //splice() 메서드
        //배열의 기존 요소를 삭제하거나 교체하고자 할때 --> 새로운 요소를 추가--> 배열의 값을 변경
        // 원본을 수정, 잘라내고(삭제) 이어 붙이기 기능

        //사용법
        //splice(start, count(몇개를 잘라낼 것인가))
        //splice(start, count, 값1, 값2)//값1, 값2 -> 잘라낸 자리에 대체할 아이템

        //잘라낸 자리에 값들을 넣는 것


        //1)
        console.clear();
        const oriAr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

        //  const splicAr1=oriAr.splice(5);
        //  console.log(splicAr1)//6,7,8,9,10
        //  console.log("원본배열 : " + oriAr)//1,2,3,4,5

        //2)

        //  const splicAr2=oriAr.splice(4,3);
        //  console.log(splicAr2)//[5, 6, 7], 4라는 것은 인덱스 번호임
        //  console.log(oriAr)// [1, 2, 3, 4, 8, 9, 10]

        //3)
        const splicAr3 = oriAr.splice(3, 2, 'a', 'b', 'c');
        console.log(splicAr3) //[4, 5]
        console.log(oriAr) // [1, 2, 3, 'a', 'b', 'c', 6, 7, 8, 9, 10]

        //4)
        const oriStrings = ['홍길도', '이순신', '강감찬', '김유신', '임꺽정'];

        // const oristring1=oriStrings.splice(2,2,"세종대왕","을지문덕")
        // console.log(oristring1)//['강감찬', '김유신']
        // console.log(oriStrings)//['홍길도', '이순신', '세종대왕', '을지문덕', '임꺽정']

        //마이너스
        // const oristring2=oriStrings.splice(-2);//뒤에서 2개
        // console.log(oristring2)//['김유신', '임꺽정']
        // console.log(oriStrings)//['홍길도', '이순신', '강감찬']

        //0 --> 새로운 요소 삽입, 삭제하는 요소 없음
        const oristring3 = oriStrings.splice(3, 0, '광개토대왕');
        console.log(oristring3) //[] 
        console.log(oriStrings) //['홍길도', '이순신', '강감찬', '광개토대왕', '김유신', '임꺽정']

        // 배열 붙이기 concat() 메서드
        console.clear();
        const myArr1 = [1, 2, 3, 4];
        const myArr2 = [5, 6, 7, 8];

        const myArr12 = myArr1.concat(myArr2);
        console.log(myArr1) // [1, 2, 3, 4]
        console.log(myArr2) //[5, 6, 7, 8]
        console.log(myArr12) // [1, 2, 3, 4, 5, 6, 7, 8]

        const myArr21 = myArr2.concat(myArr1);
        console.log(myArr21) //[5, 6, 7, 8, 1, 2, 3, 4]

        //문자열

        const str1 = "Hello";
        const str2 = "JavaScript";
        console.log(str1.concat(str2)) //HelloJavaScript
        console.log(str1.concat(' ', str2)) //Hello JavaScript
        console.log(str1.concat(', ', str2)) //Hello, JavaScript
        console.log(str2.concat(', ', str1)) //JavaScript, Hello

        const someList = ['안녕', '', '난', '', '뽀로로야 ~', '!!'];      
        console.log(...someList)//안녕 난 뽀로로야 ~ !!
        console.log(''.concat(...someList))//안녕난뽀로로야 ~!!
         // ... --> 전개 연산자(spread operator):배열의 각 요소를 개별적인 인수로 전달한다.(안에 들어있는 요소들을 묶어서 전달한다고 생각하면 됨)
    </script>
</body>

</html>