@charset "UTF-8";

* {
    margin: 0;
    padding: 0;
}

body {
    background-color: lightgray;
}

.box1 {
    position: relative;
    width: 300px;
    height: 50px;
    background-color: #fff;
    margin: 100px auto 30px;
    text-align: center;
}

.box1 .child {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: orangered;
    color: #fff;
    font-size: 22px;
    border-radius: 10px;
    line-height: 50px;

    /* 
    transition-property: transform;
    transition-duration: 0.8s;
    transition-timing-function: ease;

    //transition-timing-function: cubic-bezier(1, 1.34, 1, 2.75);는 transition-timing-function:ease의 값을 개발자모드에서 곡선을 조절하여 긁어온 값임(곡선의 가로:시간, 세로:운동의 범위) 

    transition-delay: 0.5s;/* 0.5 대기하다가 ease로 0.8동안 움직임  
    */

    /* 
    //transition: transform 0.8s 0.5s ease, background-color 0.5s;
    color: 0.3s;

    //위 주석을 줄여 적은 것, 기본값이 ease라서 적어줄 필요 없음 
    //값이 2개일땐 콤마, 밑 hover  background color가 시간을 갖지 않고 바로 올리버색으로 바껴서 0.5초의 시간을 준 것임, color도 동일한 이유 
    */

    transition: all 0.5s;
    /*all은 transform, background-color,color를 모두 포함*/

    transition: 0.5s;
    /*all은 생략 가능하고, 생략 가능하다는 뜻은 all이 숨어있다는 뜻임 */
}

.box1:hover .child {
    transform: translateY(-50px);
    background-color: olivedrab;
    color: #222;
}

/* 자식에게 hover를 주면 결국 부모에게 마우스를 올린 것과 같기 때문에 부모에게 hover를 줘야함 */



.box2 {
    width: 400px;
    font-style: 30px;
    color: #222;
    background-color: aquamarine;
    text-align: center;
    margin: 0 auto 50px;
}

.box2 p {
    transform: translateX(-100%);
    /*자기 몸의 100%로만큼 왼쪽으로 밈*/
    transition: 0.5s;
    /* all이 숨어있음 */
    transition-timing-function: cubic-bezier(0, -0.62, 0.78, 1.75);
}

.box2:hover p {
    transform: translateX(0%);
}

.box2 .one {
    transition-delay: 0.3s;
}

.box2 .two {
    transition-delay: 0.6s;
}

.box2 .three {
    transition-delay: 0.9s;
}


.box3 {
    width: 100px;
    height: 100px;
    background-color: coral;
    text-align: center;
    font-size: 30px;
    line-height: 100px;

    animation-name: box_ani;
    /*keyframes의 이름을 연결한다(연결해놓은 것을 쓰겠다) */
    animation-duration: 2s;
    /* 애니메이션의 지속시간 second의 약자(초) */
    animation-iteration-count: 1;
    /* 애니메이션의 반복횟수, 무한반복시에는 infinite라고 씀 */
    animation-direction: alternate;
    /* 애니메이션의 방향 */
    animation-direction: normal;
    /* 
    normal 기본값 
    alternate 정방향->역방향->정방향 
    alternate-reverse 역방향->정방향->역방향
    reverse 위치의 시작이 끝지점이 됨
    */
    animation-delay: 1s;
    /* 애니메이션 지연시간, 지연되는 동안은 keyframes이 안먹힘 */
    animation-timing-function: ease;
    /* 애니메이션 가속도 */
    animation-fill-mode: both;
    /* 
    애니메이션 시작 전과 끝난 후 처리방법 
    forwards 애니메이션이 끝난 상태(끝난 그자리)에서 멈춤(시작하는 시점)
    backwards 애니메이션의시작이 keyframes의 0% 상태에서 시작(끝나는 시점 설정)
    both ==> forwards + backwards (양쪽의 값을 동시에 줄 수 있음)
    */
}

/* 애니메이션움직임 제어(keyframes이 하는 일) */
@keyframes box_ani {
    from {
        /* 시간의 시작지점 0% */
        margin-left: 200px;
    }

    to {
        /* 시간의 끝나는 지점  100% */
        margin-left: 500px;
    }
}

.box4 {
    width: 100px;
    height: 100px;
    background-color: greenyellow;
    text-align: center;
    font-size: 30px;
    line-height: 100px
}

@keyframes box_ani2 {
    0% {
        transform: translate(0, 0);
    }

    25% {
        transform: translate(200px, 0);
    }

    50% {
        transform: translate(200px, 200px);
    }

    75% {
        transform: translate(0, 200px);
    }

    100% {
        transform: translate(0, 0);
    }
}